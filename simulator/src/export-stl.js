/**
 * STL exporter for T-piece geometry.
 * Converts Three.js geometry to binary STL format for 3D printing.
 */

import * as THREE from 'three';

/**
 * Export a Three.js object (mesh or group) to binary STL.
 * @param {THREE.Object3D} object
 * @returns {ArrayBuffer}
 */
export function exportSTL(object) {
  const triangles = [];

  object.traverse((child) => {
    if (child.isMesh) {
      const geometry = child.geometry.clone();

      // Apply world transforms
      child.updateWorldMatrix(true, false);
      geometry.applyMatrix4(child.matrixWorld);

      // Ensure we have non-indexed geometry
      const nonIndexed = geometry.index ? geometry.toNonIndexed() : geometry;
      const positions = nonIndexed.getAttribute('position');
      const normals = nonIndexed.getAttribute('normal');

      if (!normals) {
        nonIndexed.computeVertexNormals();
      }
      const norms = nonIndexed.getAttribute('normal');

      for (let i = 0; i < positions.count; i += 3) {
        const tri = {
          normal: new THREE.Vector3(
            norms.getX(i), norms.getY(i), norms.getZ(i)
          ),
          vertices: [
            new THREE.Vector3(positions.getX(i), positions.getY(i), positions.getZ(i)),
            new THREE.Vector3(positions.getX(i + 1), positions.getY(i + 1), positions.getZ(i + 1)),
            new THREE.Vector3(positions.getX(i + 2), positions.getY(i + 2), positions.getZ(i + 2)),
          ],
        };
        triangles.push(tri);
      }

      geometry.dispose();
      nonIndexed.dispose();
    }
  });

  // Binary STL format:
  // 80 bytes header
  // 4 bytes uint32 triangle count
  // Per triangle: 12 bytes normal + 36 bytes vertices + 2 bytes attribute
  const bufferLength = 80 + 4 + triangles.length * 50;
  const buffer = new ArrayBuffer(bufferLength);
  const view = new DataView(buffer);

  // Header (80 bytes, can be anything)
  const header = 'Seshat Fabric T-Piece - Generated by simulator';
  for (let i = 0; i < 80; i++) {
    view.setUint8(i, i < header.length ? header.charCodeAt(i) : 0);
  }

  // Triangle count
  view.setUint32(80, triangles.length, true);

  // Triangles
  let offset = 84;
  for (const tri of triangles) {
    // Normal
    view.setFloat32(offset, tri.normal.x, true); offset += 4;
    view.setFloat32(offset, tri.normal.y, true); offset += 4;
    view.setFloat32(offset, tri.normal.z, true); offset += 4;

    // Vertices
    for (const v of tri.vertices) {
      view.setFloat32(offset, v.x, true); offset += 4;
      view.setFloat32(offset, v.y, true); offset += 4;
      view.setFloat32(offset, v.z, true); offset += 4;
    }

    // Attribute byte count
    view.setUint16(offset, 0, true); offset += 2;
  }

  return buffer;
}

/**
 * Trigger browser download of an STL file.
 * @param {ArrayBuffer} stlBuffer
 * @param {string} filename
 */
export function downloadSTL(stlBuffer, filename = 't-piece.stl') {
  const blob = new Blob([stlBuffer], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
